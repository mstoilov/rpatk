#!emitall
#!emitnone


#!emit DoKeyword
#!emit FunctionCallName
#!emit IterationDo
#!emit LogicalNotExpressionOp
#!emit PostfixExpressionOp
#!emit PrefixExpressionOp
#!emit dqstring
#!emit sqstring

#!emitid SyntaxError					UID_SYNTAXERROR						1
#!emitid FunctionSyntaxError			UID_FUNCTIONSYNTAXERROR				1
#!emitid BlockSyntaxError				UID_BLOCKSYNTAXERROR				1
#!emitid GlobalSyntaxError				UID_GLOBALSYNTAXERROR				1
#!emitid IndexSyntaxError				UID_INDEXSYNTAXERROR				1
#!emitid MultiplicativeSyntaxError		UID_MULTIPLICATIVESYNTAXERROR		1
#!emitid AdditiveSyntaxError			UID_ADDITIVESYNTAXERROR				1
#!emitid AdditiveOperator				UID_BINARYOPERATOR					2
#!emitid AdditiveOperator				UID_ADDITIVEOPERATOR				2
#!emitid MultiplicativeOperator			UID_MULTIPLICATIVEOPERATOR			2
#!emitid AssignmentOperator				UID_ASSIGNMENTOPERATOR				2
#!emitid BitwiseANDOperator				UID_BITWISEANDOPERATOR				2
#!emitid BitwiseNotExpressionOp			UID_BITWISENOTEXPRESSIONOP			2
#!emitid BitwiseNotOperator				UID_BITWISENOTOPERATOR				2
#!emitid BitwiseOROperator				UID_BITWISEOROPERATOR				2
#!emitid BitwiseXOROperator				UID_BITWISEXOROPERATOR				2
#!emitid LogicalNotOperator				UID_LOGICALNOTOPERATOR				2
#!emitid LogicalOROperator				UID_LOGICALOROPERATOR				2
#!emitid LogicalANDOperator				UID_LOGICALANDOPERATOR				2
#!emitid RelationalOperator				UID_RELATIONALOPERATOR				2
#!emitid PostfixOperator				UID_POSTFIXOPERATOR					2
#!emitid PrefixOperator					UID_PREFIXOPERATOR					2
#!emitid ShiftOperator					UID_SHIFTOPERATOR					2
#!emitid EqualityOperator				UID_EQUALITYOPERATOR				2
#!emitid UnaryOperator					UID_UNARYOPERATOR					3
#!emitid This					 		UID_THIS				 			4
#!emitid Expression						UID_EXPRESSION						5
#!emitid LeftHandSideExpression			UID_LEFTHANDSIDEEXPRESSION			6
#!emitid LeftHandSideExpressionAddr		UID_LEFTHANDSIDEEXPRESSIONADDR		7
#!emitid AdditiveExpressionOp			UID_ADDITIVEEXPRESSIONOP			8
#!emitid MultiplicativeExpressionOp		UID_MULTIPLICATIVEEXPRESSIONOP		9
#!emitid BitwiseANDOp					UID_BITWISEANDOP					10
#!emitid BitwiseXOROp					UID_BITWISEXOROP					11
#!emitid BitwiseOROp					UID_BITWISEOROP						12
#!emitid ShiftExpressionOp				UID_SHIFTEXPRESSIONOP				13
#!emitid EqualityExpressionOp			UID_EQUALITYEXPRESSIONOP			14
#!emitid RelationalExpressionOp			UID_RELATIONALEXPRESSIONOP			15
#!emitid LogicalOROp					UID_LOGICALOROP						16
#!emitid LogicalANDOp					UID_LOGICALANDOP					17
#!emitid VariableAllocate				UID_VARIABLEALLOCATE				18
#!emitid VariableAllocateAndInit		UID_VARIABLEALLOCATEANDINIT			19
#!emitid IdentifierName					UID_IDENTIFIERNAME					20
#!emitid Identifier						UID_IDENTIFIER						21
#!emitid Initialiser					UID_INITIALISER						22
#!emitid AssignmentExpressionOp			UID_ASSIGNMENTEXPRESSIONOP			23
#!emitid NewArrayExpression				UID_NEWARRAYEXPRESSION				24
#!emitid MemberExpressionDotOp			UID_MEMBEREXPRESSIONDOTOP			25
#!emitid MemberExpressionIndexOp		UID_MEMBEREXPRESSIONINDEXOP			26
#!emitid FunctionName					UID_FUNCTIONNAME					27
#!emitid FunctionDeclaration			UID_FUNCTIONDECLARATION				28
#!emitid FunctionParameter				UID_FUNCTIONPARAMETER				29
#!emitid FormalParameterList			UID_FORMALPARAMETERLIST				30
#!emitid CallExpression					UID_CALLEXPRESSION					31
#!emitid FunctionCall					UID_FUNCTIONCALL					32
#!emitid Argument						UID_ARGUMENT						33
#!emitid Arguments						UID_ARGUMENTS						34
#!emitid ReturnStatement				UID_RETURNSTATEMENT					35
#!emitid DoubleStringCharacters			UID_STRINGCHARACTERS				36
#!emitid SingleStringCharacters			UID_STRINGCHARACTERS				36
#!emitid IfStatement					UID_IFSTATEMENT						37
#!emitid IfConditionOp					UID_IFCONDITIONOP					38
#!emitid IfTrueStatement				UID_IFTRUESTATEMENT					39
#!emitid IfFalseStatement				UID_IFFALSESTATEMENT				40
#!emitid Block							UID_BLOCK							41
#!emitid IterationFor					UID_ITERATIONFOR					42
#!emitid ForExpressionInit				UID_FOREXPRESSIONINIT				43
#!emitid ForExpressionCompare			UID_FOREXPRESSIONCOMPARE			44
#!emitid ForExpressionIncrement			UID_FOREXPRESSIONINCREMENT			45
#!emitid ForIterationStatement			UID_FORITERATIONSTATEMENT			46
#!emitid PostfixExpressionOp			UID_POSTFIXEXPRESSIONOP				47
#!emitid PrefixExpressionOp				UID_PREFIXEXPRESSIONOP				48
#!emitid NewExpressionCall				UID_NEWEXPRESSIONCALL				49
#!emitid FunctionExpression				UID_FUNCTIONEXPRESSION				50
#!emitid UnaryExpressionOp				UID_UNARYEXPRESSIONOP				51
#!emitid DecimalIntegerLiteral			UID_DECIMALINTEGERLITERAL			52
#!emitid DecimalNonIntegerLiteral		UID_DECIMALNONINTEGERLITERAL		53
#!emitid BreakStatement					UID_BREAKSTATEMENT					54
#!emitid ContinueStatement				UID_CONTINUESTATEMENT				55
#!emitid IterationWhile					UID_ITERATIONWHILE					56
#!emitid IterationDo					UID_ITERATIONDO						57
#!emitid WhileExpressionCompare			UID_WHILEEXPRESSIONCOMPARE			58
#!emitid DoWhileExpressionCompare		UID_DOWHILEEXPRESSIONCOMPARE		59
#!emitid Program 						UID_PROGRAM 						60


# 6 Source Text
SourceCharacter			::= .

# 7.2 White space
WhiteSpace				::= [#0x0009] | [#0x000B] | [#0x000C] | [#0x0020] | [#0x00A0] | [#0xFEFF]

# 7.3 Line Terminators
LineTerminator			::= [#0x000D] [#0x000A] | ([#0x000A] | [#0x000D] | [#0x2028] | [#0x2029])
LineTerminatorSequence	::= [#0x000D] [#0x000A] | [#0x000A] | [#0x000D] | [#0x2028] | [#0x2029]
S						::= ( <WhiteSpace> | <LineTerminator> )+
SC						::= <S>? ';' <S>?
COMMA					::= <S>? ',' <S>?
EQ						::= <S>? '=' <S>?

# 7.4 Comments
Comment					::= <MultiLineComment> | <SingleLineComment>
MultiLineComment		::= '/*' <MultiLineCommentChar>* '*/'
MultiLineCommentChar	::= . - '*/'
SingleLineComment		::= '#' <SingleLineCommentChar>*
SingleLineCommentChar	::= <SourceCharacter> - <LineTerminator>

# 7.5 Tokens
Token					::= <IdentifierName> |
			    			<NumericLiteral> |
			    			<StringLiteral>

# 7.6 Identifier Names and Identifiers

Identifier				::= <IdentifierNameNoEmit> - (<ReservedWord> - <ReservedWord> <IdentifierPart>)
IdentifierNoEmit		::= <IdentifierNameNoEmit> - (<ReservedWord> - <ReservedWord> <IdentifierPart>)
IdentifierName			::= <IdentifierStart> <IdentifierPart>*
IdentifierNameNoEmit	::= <IdentifierStart> <IdentifierPart>*
IdentifierStart			::= <UnicodeLetter> | '$' | '_' | '\' <UnicodeLetter>
UnicodeLetter			::= [#0x0041-#0x005A] | [#0x00C0-#0x00DE] | [#0x0100-#0x0232] | [#0x0061-#0x007A] | [#0x00C0-#0x00DE]	    # <Lu> | <Ll>

Lu						::= [#0x0041-#0x005A] | [#0x00C0-#0x00DE] | [#0x0100-#0x0232]  	# TBD
Ll						::= [#0x0061-#0x007A] | [#0x00C0-#0x00DE] 						# TBD
IdentifierPart			::= <IdentifierStart> | 
				    		<UnicodeDigit> 
UnicodeDigit			::= [0-9] | [#0x0660-#0x0669]					# TBD

ReservedWord			::= <NullLiteral> |
							<BooleanLiteral> |
							<Keyword> |
							<FutureReservedWord>

Keyword					::= 'instanceof' | 'typeof'	| 'break' |
			    			'do' | 'new' | 'var' |
			    			'case' | 'else' | 'return' | 'void' | 
			    			'catch' | 'finally' | 'continue' | 'for' | 
			    			'switch' | 'while' | 'this' | 'with' | 
			    			'debugger' | 'function' | 'throw' | 'default' |  
			    			'if' | 'try' | 'delete' | 'in'

FutureReservedWord			::= 'class' | 'enum' | 'extends' | 'import' | 'const' | 'export' |
			    				'implements' | 'let' | 'private' | 'public' |
                            	'static' | 'interface' | 'package' | 'protected'

NullLiteral					::= 'null'
BooleanLiteral 				::= 'true' | 'false'
Literal 					::= <NullLiteral> |
			    				<BooleanLiteral> |
			    				<NumericLiteral> |
			    				<StringLiteral>
			    				
LiteralOp					::= <Literal>

# 7.8.3 Numeric Literals

NumericLiteral					::= <HexIntegerLiteral> | <DecimalNonIntegerLiteral> | <DecimalIntegerLiteral>
DecimalNonIntegerLiteral		::= ('0' | <NonZeroDigit> <DecimalDigits>?) '.' <DecimalDigits>? <ExponentPart>? |
			    					'.' <DecimalDigits> <ExponentPart>? 
DecimalIntegerLiteral			::= '0' | <NonZeroDigit> <DecimalDigits>? <ExponentPart>?
DecimalDigits					::= <DecimalDigit>+
DecimalDigit					::= [0-9]
NonZeroDigit					::= [1-9]
ExponentPart					::= <ExponentIndicator> <SignedInteger>
ExponentIndicator 				::= [eE]
SignedInteger 					::= '-' <DecimalDigits> |
			    					'+' <DecimalDigits> |
			    					<DecimalDigits>
HexIntegerLiteral 				::= '0' [xX] <HexDigit>+
HexDigit 						::= [0-9a-fA-F]

# 7.8.4 String Literals
StringLiteral					::= '"' <DoubleStringCharacters>? '"' |
			    					"'" <SingleStringCharacters>? "'"

DoubleStringCharacters			::= <DoubleStringCharacter>+
SingleStringCharacters			::= <SingleStringCharacter>+

DoubleStringCharacter			::= <SourceCharacter> - ('"' | '\\' | <LineTerminator>)

SingleStringCharacter			::= <SourceCharacter> - ("'" | '\\' | <LineTerminator>)
This							::= 'this'

PrimaryExpression				::= <This> | 
			    					'(' <S>? <Expression> <S>? ')' |
			    					<Literal> |
			    					<Identifier>




ArrayLiteral 					::= '[' <S>? <Elision>? <S>? ']' |
			    					'[' <S>? <ElementList> <S>? ']' |
			    					'[' <S>? <ElementList> <S>? ',' <S>? <Elision> <S>? ']'
ElementList						::= <Elision>? <S>? <AssignmentExpression> (<S>? ',' <S>? <Elision>? <S>? <AssignmentExpression> )*
Elision							::= ',' <S>? <Elision> | <S>? ','


# 11.2 Left-Hand-Side Expressions
IndexSyntaxError				::= '[' (. - <SC>)*
MemberExpressionBase			::= <MemberExpression>
MemberExpressionIndexOp			::= <MemberExpressionBase> <S>? (('[' <S>? <Expression> <S>? ']' <S>?) | <IndexSyntaxError>) 
MemberExpressionDotOp			::= <MemberExpressionBase> '.' <IdentifierName>

MemberExpression 				::= <MemberExpressionIndexOp>  |
									<MemberExpressionDotOp> |
									<FunctionExpression> |
									<PrimaryExpression>
									
NewKeyword						::= 'new' - 'new' <IdentifierPart>
NewExpressionCall				::= <NewKeyword> <S>? <MemberExpression> <S>? <Arguments>?

NewExpression 					::= <NewExpressionCall> |
									<MemberExpression>

# NewExpression 					::= <NewKeyword> <S>? <NewExpression> |
#									<MemberExpression>


FunctionCallName				::= <CallExpression> | <MemberExpression>
FunctionCall					::= <FunctionCallName> <S>? <Arguments>
CallExpression					::= <CallExpression> <S>? '[' <S>? Expression <S>? ']' |
									<CallExpression> '.' <IdentifierName> |
									<FunctionCall>

Arguments						::= '(' <S>? ')' |
			    					'(' <S>? <ArgumentList> <S>? ')'
Argument						::= <AssignmentExpression>
ArgumentList					::= <ArgumentList> <S>? ',' <S>? <Argument> |
									<Argument>
LeftHandSideExpression			::= <CallExpression> | <NewExpression>
LeftHandSideExpressionAddr		::= <CallExpression> | <NewExpression>


# 11.3 Postfix Expressions
# RULE: LeftHandSideExpression always ends up in R0 (Let see if this would work)
PostfixOperator 				::= '++' | '--'
PostfixExpressionOp 			::= <LeftHandSideExpressionAddr> <PostfixOperator>
PostfixExpression 				::= <PostfixExpressionOp> | <LeftHandSideExpression> 

PrefixOperator 					::= '++' | '--'
PrefixExpressionOp 				::= <PrefixOperator> <LeftHandSideExpressionAddr>
PrefixExpression 				::= <PrefixExpressionOp> | <PostfixExpression>

# 11.4 Unary Operators
UnaryOperator					::= '~' | '!' | ('+' - '++') | ('-' - '--') | 'delete' | 'void' | 'typeof'
UnaryExpressionOp	    		::=	<S>? <UnaryOperator> <S>? <UnaryExpression>
UnaryExpression		    		::=	<UnaryExpressionOp> | <PrefixExpression>


# 11.5 Multiplicative Operators
MultiplicativeSyntaxError		::= <MultiplicativeOperator>  
MultiplicativeOperator 			::= '*' | '/' | '%'
MultiplicativeExpressionOp		::= <MultiplicativeExpression> <S>? ((<MultiplicativeOperator> <S>? <UnaryExpression>) | <MultiplicativeSyntaxError>)
MultiplicativeExpression		::= <MultiplicativeExpressionOp> | 
									<UnaryExpression>

# 11.6 Additive Operators
AdditiveSyntaxError				::= <AdditiveOperator>  
AdditiveOperator 				::= '+' | '-'
AdditiveExpressionOp			::= <AdditiveExpression> <S>? ((<AdditiveOperator> <S>? <MultiplicativeExpression>) | <AdditiveSyntaxError>)
AdditiveExpression				::= <AdditiveExpressionOp> | 
									<MultiplicativeExpression>


11.7 Bitwise Shift Operators
ShiftOperator					::= '>>>' | '<<' | '>>'
ShiftExpressionOp				::= <ShiftExpression> <S>? <ShiftOperator> <S>? <AdditiveExpression>
ShiftExpression					::= <ShiftExpressionOp> |
			    					<AdditiveExpression> 


# 11.8 Relational Operators
RelationalOperator		 		::= '<=' | '>=' | '<' | '>' | 'instanceof'
RelationalExpressionOp			::= <RelationalExpression> <S>? <RelationalOperator> <S>? <ShiftExpression>
RelationalExpression 			::= <RelationalExpressionOp> |
			    					<ShiftExpression>

# 11.9 Equality Operators
EqualityOperator 				::= '===' | '==' | '!==' | '!='
EqualityExpressionOp 			::= <EqualityExpression> <S>? <EqualityOperator> <S>? <RelationalExpression> 
EqualityExpression 				::= <EqualityExpressionOp> |
			    					<RelationalExpression>

BitwiseANDOperator 				::= '&' - '&&'
BitwiseANDOp		 			::= <BitwiseANDExpression> <S>? <BitwiseANDOperator> <S>? <EqualityExpression>
BitwiseANDExpression 			::= <BitwiseANDOp> |
			    					<EqualityExpression>

BitwiseXOROperator 				::= '^'
BitwiseXOROp		 			::= <BitwiseXORExpression> <S>? <BitwiseXOROperator> <S>? <BitwiseANDExpression>
BitwiseXORExpression 			::= <BitwiseXOROp> |
			    					<BitwiseANDExpression>

BitwiseOROperator 				::= '|' - '||'
BitwiseOROp		 				::= <BitwiseORExpression> <S>? <BitwiseOROperator> <S>? <BitwiseXORExpression>
BitwiseORExpression 			::= <BitwiseOROp> |
			    					<BitwiseXORExpression>

# 11.11 Binary Logical Operators
LogicalANDOperator 				::= '&&'
LogicalANDOp		 			::= <LogicalANDExpression> <S>? <LogicalANDOperator>  <S>? <BitwiseORExpression>
LogicalANDExpression 			::= <LogicalANDOp> |
			    					<BitwiseORExpression>

LogicalOROperator 				::= '||'
LogicalOROp			 			::= <LogicalORExpression> <S>? <LogicalOROperator> <S>? <LogicalANDExpression>
LogicalORExpression 			::= <LogicalOROp> |
			    					<LogicalANDExpression>


# 11.12 Conditional Operator ( ? : )
ConditionalExpression 			::= <LogicalORExpression> ( <S>? '?' <S>? <AssignmentExpression> <S>? ':' <S>? <AssignmentExpression> )?

# 11.13 Assignment Operators
AssignmentExpressionOp 			::= <LeftHandSideExpressionAddr> <S>? <AssignmentOperator> <S>? <AssignmentExpression>
AssignmentExpression 			::= <AssignmentExpressionOp> | <ConditionalExpression>
AssignmentOperator 				::= '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|='


# 11.14 Comma Operator 	( , )
Expression    					::= <AssignmentExpression> ( <S>? ',' <S>? <AssignmentExpression> )*


# 12 Statements
Statement						::= <FunctionDeclarationStatement> |
			    					<ExpressionStatement> |
									<ContinueStatement> |
									<Block> |
			    					<Comment> |
			    					<VariableStatement> |
			    					<EmptyStatement> |
			    					<IfStatement> |
			    					<IterationStatement> |
			    					<ContinueStatement> |
			    					<BreakStatement> |
			    					<ReturnStatement> |
			    					<WithStatement> |
			    					<SwitchStatementOp>

# 12.1 Block
Block								::= <S>? '{' <S>? <StatementList>? <S>? ('}' | <BlockSyntaxError>) <S>?
StatementList						::= (<S>? <Statement>)+

# 12.2 Variable Statement
VariableStatement 					::= 'var' <S>? <VariableDeclarationList> <SC>
VariableDeclarationList 			::= <VariableDeclaration> (<COMMA> <VariableDeclaration> )*
VariableAllocate					::= <IdentifierNoEmit>
VariableAllocateAndInit				::= <IdentifierNoEmit>
VariableDeclaration					::= <VariableAllocateAndInit> <Initialiser> | <VariableAllocate>
Initialiser							::= <EQ> <AssignmentExpression>


# 12.3 Empty Statement
EmptyStatement						::= <SC>

# 12.4 Expression Statement
ExpressionStatement 				::= (<Expression> - ('function' | '{')) <SC>


# 12.5 The if Statement
IfConditionOp						::= 'if' <S>? '(' <S>? <Expression> <S>? ')'
IfTrueStatement						::= <Statement>
IfFalseStatement					::= <Statement>
IfStatement							::= <IfConditionOp> <S>? <IfTrueStatement> <S>? 'else' <S>? <IfFalseStatement> |
			    						<IfConditionOp> <S>? <IfTrueStatement> 

# 12.6 Iteration Statements
# 12.6a Iteration do ... while() 
DoWhileExpressionCompare			::= <Expression>
IterationDo							::= 'do' <S>? <Statement> <S>? 'while' <S>? '(' <S>? <DoWhileExpressionCompare> <S>? ')' (<S>? ';')

# 12.6b Iteration while()
WhileExpressionCompare				::= <Expression>
IterationWhile						::= 'while' <S>? '(' <S>? <WhileExpressionCompare> <S>? ')' <S>? <Statement>

# 12.6c Iteration for ( ; ; )
ExpressionNoIn						::= <Expression>
ForExpressionInit					::= ('var' <S>? <VariableDeclarationList>) | <ExpressionNoIn>
ForExpressionCompare				::= <Expression>
ForExpressionIncrement				::= <Expression>
ForIterationStatement				::= <Statement>
IterationFor						::= 'for' <S>? '(' <S>? <ForExpressionInit>? <S>? ';' <S>? <ForExpressionCompare>? <S>? ';' <S>? <ForExpressionIncrement>? <S>? ')' <S>? <ForIterationStatement>


IterationStatement 					::= <IterationWhile> |
										<IterationFor> |
	    								<IterationDo>

# 12.9 The return Statement
ReturnOp							::= ('return' - 'return' <IdentifierPart>) <WhiteSpace>* <AssignmentExpression>? (<S>? ';')
ReturnStatement						::= ('return' - 'return' <IdentifierPart>) <WhiteSpace>* <AssignmentExpression>? (<S>? ';')

# The Break Statement
BreakOp								::= 'break' - 'break' <IdentifierPart>
BreakStatement						::= <S>? <BreakOp> <SC>

# The Continue Statement
ContinueOp							::= 'continue' - 'continue' <IdentifierPart>
ContinueStatement					::= <S>? <ContinueOp> <SC>



# 12.10 The with Statement
WithStatement						::= 'with' <S>? '(' <S>? <Expression> <S>? ')' <S>? <Statement>


# 12.11 The switch Statement
SwitchExpressionOp					::= ('switch' - 'switch' <IdentifierPart>) <S>? '(' <S>? <Expression> <S>? ')'
SwitchStatementOp					::= <SwitchExpressionOp> <S>? <CaseBlock>

CaseBlock							::= '{' <S>? <CaseClauses>? <S>? <DefaultClauseOp>? <S>? <CaseClauses>? <S>? '}' |
				    					'{' <S>? <CaseClauses>? <S>? '}'



CaseClauses 						::= (<S>? <CaseClauseOp>)+
CaseExpressionOp					::= ('case' - 'case' <IdentifierPart>) <S>? <Expression> <S>? ':'
CaseClauseOp						::= <CaseExpressionOp> <S>? <StatementList>?
DefaultKeywordOp					::= 'default' - 'default' <IdentifierPart>
DefaultClauseOp						::= <DefaultKeywordOp> <S>? ':' <S>? <StatementList>?


# 13 Function Definition
FunctionName						::= <IdentifierNoEmit>
FunctionDeclaration					::= ('function'-'function'<IdentifierPart>)<S>?<FunctionName><S>?'('<S>?<FormalParameterList>?<S>?')'<S>?'{'<S>?<FunctionBody>?<S>? ('}' | <FunctionSyntaxError>)
FunctionExpression					::= ('function'-'function'<IdentifierPart>)<S>?<FunctionName>?<S>?'('<S>?<FormalParameterList>?<S>?')'<S>?'{'<S>?<FunctionBody>?<S>?('}' | <FunctionSyntaxError>)
FormalParameterList 				::= <FunctionParameter> ( <S>? ',' <S>? <FunctionParameter> )*
FunctionParameter 					::= <IdentifierNoEmit>
# FunctionBody						::= <SourceElements>
FunctionBody						::= (<S>? (<SourceElement> ))+
FunctionDeclarationStatement		::= ('function' - 'function' <IdentifierPart>)<S>?<FunctionName><S>?'('<S>?<FormalParameterList>?<S>?')' <SC>

# FunctionName						::= <IdentifierNoEmit>
# FunctionNameLookupAlloc			::= <IdentifierNoEmit>
# FunctionDefinition				::= ('function' - 'function' <IdentifierPart>)<S>?<FunctionName><S>?'('<S>?<FormalParameterList>?<S>?')'
# FunctionDeclaration				::= <FunctionDefinition><S>?'{'<S>?<FunctionBody>?<S>?'}'
# FunctionExpression				::= ('function' - 'function'<IdentifierPart>)<S>?<FunctionName>?<S>?'('<S>?<FormalParameterList>?<S>?')'<S>?'{'<S>?<FunctionBody>?<S>?'}'
# FunctionParameter 				::= <Identifier>
# FormalParameterList 				::= <FunctionParameter> ( <S>? ',' <S>? <FunctionParameter> )*
# FunctionDefinitionStatement		::= ('function' - 'function' <IdentifierPart>)<S>?<FunctionNameLookupAlloc><S>?'('<S>?<FormalParameterList>?<S>?')' <SC>
# FunctionBody						::= <SourceElements>


# 14 Program
BlockSyntaxError				::= (. - '}')+ '}'
FunctionSyntaxError				::= (. - '}')+ '}'
GlobalSyntaxError				::= (. - <SC>)+

SourceElements 					::= (<S>? <SourceElement>)+
SourceElement 					::= <FunctionDeclaration> |
			    					<Statement> 
Program							::= <SourceElements> | <GlobalSyntaxError>
# The root rule, it is anonymous
<Program>


